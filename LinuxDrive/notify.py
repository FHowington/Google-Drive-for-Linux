import logging
import os
import inotify.adapters
from fileUpdate import Update
from os import walk

_DEFAULT_LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
_LOGGER = logging.getLogger(__name__)


class NotifyMonitor:
    """
    This handles events generated by iNotify and processes them into drive API calls appropriately
    """

    def __init__(self, base_folder, base_path, base_id, drive, save_file=None):
        self.base_folder = base_folder
        self.base_path = base_path
        self.base_id = base_id
        self.drive = drive
        self.logger = logging.getLogger('Drive_Linux')
        self.update = Update(base_id=base_id, drive=drive, base_path=base_path, save_file=save_file)

    def monitor(self, force_update, save_file=False):
        temp_name = None
        temp_cookie = None
        temp_path = None

        i = inotify.adapters.Inotify()
        for (dirpath, dirnames, filenames) in walk(self.base_path):
            i.add_watch(bytes(dirpath, encoding="utf-8"))

        if force_update:
            self.logger.info("Synchronizing entire folder structure")
            self.update.multi_add(watch_path=self.base_path, notify=i)
            self.logger.info("Sync complete")

        try:
            for event in i.event_gen():
                if event is not None:
                    (header, type_names, watch_path, filename) = event

                    if "IN_CLOSE_WRITE" in type_names:
                        """ 
                        This indicates that the file was saved. Initial creation of a file may generate
                        this as well as an IN_CREATE, but the uploader should be able to prevent multiple copies 
                        """
                        if not os.path.isdir(watch_path.decode("utf-8") + "/" + filename.decode("utf-8")):
                            self.update.update(watch_path.decode("utf-8"), [filename.decode("utf-8")])

                    elif "IN_CREATE" in type_names:

                        """
                        This indicates that whatever was just created was a folder. This must be handled differently
                        than a newly created file would be
                        """
                        if os.path.isdir(watch_path.decode("utf-8") + "/" + filename.decode("utf-8")):
                            self.update.update_folder(
                                full_path=watch_path.decode("utf-8") + "/" + filename.decode("utf-8"))
                            i.add_watch(
                                bytes((watch_path.decode("utf-8") + "/" + filename.decode("utf-8")),
                                      encoding="utf-8"))

                            """
                            Because pasting a folder does not raise iNotify events for the files within the folder
                            we need to manually query the folder for it's contents
                            """
                            self.logger.info("Adding all contents of folder " + watch_path.decode("utf-8") + "/" +
                                             filename.decode("utf-8"))

                            self.update.multi_add(
                                watch_path=watch_path.decode("utf-8") + "/" + filename.decode("utf-8"), notify=i)

                        else:
                            self.update.update(watch_path.decode("utf-8"), [filename.decode("utf-8")])

                    elif "IN_MOVED_FROM" in type_names:
                        temp_cookie = header.cookie
                        temp_path = watch_path
                        temp_name = filename

                    elif "IN_MOVED_TO" in type_names:
                        if header.cookie == temp_cookie:

                            # Determining if this was a rename or a move
                            if temp_path == watch_path:
                                if os.path.isdir(watch_path.decode("utf-8") + "/" + filename.decode("utf-8")):
                                    i.add_watch(bytes(
                                        (watch_path.decode("utf-8") + "/" + filename.decode("utf-8")),
                                        encoding="utf-8"))

                                self.update.rename_file(temp_name.decode("utf-8"),
                                                        filename.decode("utf-8"),
                                                        watch_path.decode("utf-8"), i)
                            else:
                                self.logger.info(filename.decode("utf-8") + " has been moved from " + temp_path.decode(
                                    "utf-8") + " to " + watch_path.decode("utf-8"))
                                self.update.move(temp_path.decode("utf-8"), watch_path.decode("utf-8"),
                                                 filename.decode("utf-8"))

        finally:
            if save_file:
                save_file.close()
            self.logger.info("Shutting down.")
